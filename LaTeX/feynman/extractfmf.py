#! /usr/bin/env python3
# Author: Izaak Neutelings (August 2024)
# Description: Extract fmffile/fmfpicture for https://feynm.net/
# Sources:
#   https://www.geeksforgeeks.org/convert-pdf-to-image-using-python/
# Instructions:
#   python3 -m pip install pdf2image pillow pypdf
#   ./extractfmf.py -p basic_QED.tex
import os, re
import stat #shutil
import glob
from datetime import datetime
from PIL import Image, ImageSequence, ImageFile
#from pdf2image import convert_from_path
import pdf2image
from pypdf import PdfReader, PdfWriter
rexp_docbeg  = re.compile(r"\\begin\{document\}")
rexp_fmfbeg  = re.compile(r"\\begin\{fmf(file|picture)\}")
rexp_fmfend  = re.compile(r"\\end\{(file|fmfpicture)\}")
rexp_fmfpic  = re.compile(r"\\begin\{fmfpicture\}\{([^\}%]+)\}\{([^\}%]+)\}(\{[^\}]+\}[^\}]*)$")
rexp_fmfgrp  = re.compile(r"\\begin\{fmfgraph\*?\}")
rexp_defcol  = re.compile(r"(?<!\%)\\definecolor\{(\w+)\}(.+)$")
rexp_fmfset  = re.compile(r"\s*\\fmfset\{.+$")
rexp_fmfcmd  = re.compile(r"\s*\\fmfcmd\{\s*.+$")
rexp_newcmd  = re.compile(r"^\s*((\\newcommand)\{?(\\[a-zA-Z]+)\}?(?:\[\d+\])?\{)(.*)$")
rexp_macro   = re.compile(r"\s*(\\def)(\\[a-zA-Z]+)\{(.*)$")
rexp_style   = re.compile(r"\s*style_def (\w+)")
rexp_foreach = re.compile(r"\s*\\foreach\s*(\\\w+)\s*in\s*\{(.+)\}\{[^\{]*$")
rexp_mathrm  = re.compile(r"([a-zA-Z])?\$\\mathrm\{([^\}]+)\}\$")
rexp_deffor  = re.compile(r"^\s*\\def(\\foreach[a-zA-Z]+)[^\{]+\{.+ (\\\w+) in \{(.+)\}\{\#1\}\}")

class Color:
  def __init__(self,match):
    #print(match.groups())
    rgbmatch = re.search(r"\{([\.\d]+),([\.\d]+),([\.\d]+)\}",match.group(2))
    assert rgbmatch, f"Did not find RGB value for line={line!r}"
    self.name       = match.group(1) # color name/key
    self.longname   = 'color{'+self.name+'}' # color name/key 'color{colname}'
    self.definition = match.group(0)+'\n'
    self.rgb        = f"({',,'.join(rgbmatch.groups())})"
    #self.rexp_cmd   = re.compile('\\'+self.name+'(?!\w)')
    #print(f">>> Color: name={self.name!r}, definition={self.definition!r}, rgb={self.rgb!r}")
  

def green(string,**kwargs):
  return "\033[32m%s\033[0m"%string
  

def bold(string):
  return "\033[1m%s\033[0m"%(string)
  

def execute(cmd):
  cmd = bold(repr(cmd))
  print(f">>> Executing {cmd}")
  os.system(cmd)
  

def ensuredir(dname,verb=0):
  """Make directory if it does not exist."""
  if not os.path.exists(dname):
    if verb>=1:
      print(f">>> Making directory {dname}...")
    os.makedirs(dname,exist_ok=True)
  return dname
  

def rreplace(string,old,new='',count=1,warn=True):
  """Replace occurrences substring from right to left."""
  if warn and count==1 and not string.endswith(old):
    print(">>> rreplace: string {string!r} does not end with {old!r}!")
  parts = string.rsplit(old,count)
  return new.join(parts)
  

def getpdfname(infname,outdir=''):
  """Make PDF name from given input file name."""
  outfname = os.path.basename(infname)
  pdffname = os.path.join(outdir,rreplace(outfname,'.tex','.pdf'))
  return pdffname
  

def readscope(infile,line,rmindent=True,skipempty=True,inclend=False):
  """Help function to read all lines within curly braces."""
  isvalid = False
  nopen   = 1 # number of left braces
  nclosed = 0 # number of right braces
  lines = [ ]
  while line or line=='':
    nopen   += line.count('{')
    nclosed += line.count('}')
    if nopen==nclosed and not inclend: # found end of macro
        idx  = line.rfind('}')
        #line = '' if line[:idx].strip()=='' else line[idx:]
        line = '' if line[:idx].strip()=='' else line[:idx]
    if line and not (skipempty and line in " \n"): # do not add empty lines
      lines.append(line)
    line = infile.readline() # read next line
    assert nopen>=nclosed, (f"Found more closed ({nclosed}) than open braces ({nopen})..."
                            f" Lines={lines}")
    if nopen==nclosed:
      isvalid = True
      break
  if rmindent and isvalid: # found end of macro
    print(lines)
    npad = min(len(l)-len(l.lstrip()) for l in lines)
    if npad>=1: # remove padding in each line
      lines = [l[npad:] for l in lines]
  return isvalid, line, lines


def createscript(infname,outdir='extract',verb=0):
  """Create script to compile LaTeX file."""
  assert infname.count('.tex')==1
  assert infname.endswith('.tex')
  tmpdir   = os.path.join(outdir,'tmp')
  outfname = os.path.basename(infname)
  scrname  = os.path.join(outdir,rreplace(outfname,'.tex','.sh'))
  pdffname = getpdfname(outfname,outdir='')
  if ' ' in infname:
    infname = f"'{infname}'"
  pdfcmd = f"pdflatex -shell-escape ../{outfname}"
  print(f">>> createscript: Creating compilation script {scrname}...")
  with open(scrname,'w') as script:
    script.write('#! /bin/bash\n')
    script.write(f"# Auto-generated by {__file__} on {datetime.now().strftime('%d/%m/%Y, %H:%M:%S')}\n")
    script.write('function peval { echo -e ">>>> $@"; eval "$@"; }\n\n')
    script.write(f'peval "mkdir -p {tmpdir}"\n')
    script.write(f'peval "cp -v {infname} {outdir}/"\n')
    #script.write(f'peval "cp -v {infname} {tmpdir}/"\n')
    script.write(f'peval "cd {tmpdir}/"\n')
    script.write(f'peval "{pdfcmd} && {pdfcmd}"\n')
    script.write(f'peval "mv {pdffname} ../"\n')
    script.write(f'peval "rm feynmp-*[^.sh].{{1,t1,mp,log,aux}}"\n') # clean
  os.chmod(scrname,stat.S_IRWXU) # allow execution
  return scrname
  

def tex2pdf(fname,outdir='extract',verb=0):
  """Compile LaTeX file with feynmp."""
  logname = os.path.join(outdir,os.path.basename(rreplace(fname,'.tex','.sh.log')))
  script = createscript(fname,outdir=outdir,verb=verb)
  print(f">>> tex2pdf: Running {script}...")
  os.system(f"{script} | tee {logname}")
  

def splitpdf(pdffname,verb=0):
  """Splits a multi-page PDF into single-page PDFs (without rasterization)."""
  subpdfname = rreplace(pdffname,'.pdf',f"$TAG.pdf")
  if verb>=0:
    print(f">>> splitpdf: Splitting {pdffname} -> {subpdfname}...")
  reader = PdfReader(pdffname)
  pdfnames = [ ]
  for i, page in enumerate(reader.pages,1):
    tag = f"-{i:03}"
    pdfname_ = subpdfname.replace('$TAG',tag)
    if verb>=1:
      print(f">>> splitpdf: Splitting {pdffname}[{i}] -> {pdfname_}...")
    writer = PdfWriter()
    writer.add_page(page)
    with open(pdfname_,'wb') as pdffile:
      writer.write(pdffile)
    pdfnames.append(pdfname_)
  return pdfnames
  

def pdf2png(pdffname,resolution=1000,verb=0):
  """Convert PDF to PNG file."""
  pngname = rreplace(pdffname,'.pdf',f"$TAG.png")
  if verb>=0:
    print(f">>> pdf2png: Converting {pdffname} -> {pngname}...")
  assert os.path.isfile(pdffname), f"pdffname={pdffname} is not a file... PWD={os.getcwd()}"
  pages = pdf2image.convert_from_path(pdffname,resolution)
  pngnames = [ ]
  for i, page in enumerate(pages,1):
    tag = f"-{i:03}"
    pngname_ = pngname.replace('$TAG',tag)
    if verb>=1:
      print(f">>> pdf2png: Converting {pdffname}[{i}] -> {pngname_}...")
    page.save(pngname_,'PNG')
    pngnames.append(pngname_)
  return pngnames
  

def png2gif(pdffname,pngnames,duration=1000,verb=0):
  """Convert PDF to PNG file."""
  gifname = rreplace(pdffname,'.pdf','.gif')
  if verb>=0:
    print(f">>> png2gif: Converting {pdffname} -> {gifname}...")
  assert os.path.isfile(pdffname), f"pdffname={pdffname} is not a file... PWD={os.getcwd()}"
  pngs = [Image.open(p) for p in pngnames]
  wmax = max(p.width for p in pngs)
  hmax = max(p.height for p in pngs)
  newpngs = [ ] # ensure same size
  for oldpng in pngs:
    scale   = min(wmax/oldpng.width,hmax/oldpng.height) # use the smaller ratio to avoid stretching
    newsize = (int(scale*oldpng.width),int(scale*oldpng.height))
    oldpng  = oldpng.resize(newsize,Image.LANCZOS) #Image.LANCZOS or Image.Resampling.LANCZOS
    newpng  = Image.new('RGBA',(wmax,hmax),(255,255,255,1)) # white, nontransparent background
    newpng.paste(oldpng,(int((wmax-newsize[0])/2), int((hmax-newsize[1])/2))) # paste in center
    newpngs.append(newpng)
  newpngs[0].save(gifname,save_all=True,append_images=newpngs[1:],duration=duration,loop=0)
  return gifname
  

def getfilesize(infname,verb=0):
  """Get file sizes in kB."""
  fnames = glob.glob(rreplace(infname,'.pdf','*.*'))
  for fname in sorted(fnames):
    size = os.path.getsize(fname)/1024 # kB
    #size = os.path.getsize(fname)/(1024)**2 # MB
    print(f">>> {size:>8.0f} kb  {fname}")
  

def write_preamble(outfname,infile,line,rexp_end=rexp_docbeg,presets=None,
                   col_dict=None,for_dict=None,cmd_dict=None,mac_dict=None,verb=0):
  """Read & write preamble."""
  print(f">>> write_fmf: Writing outfname={green(outfname)}...")
  #print(f">>> write_fmf: Writing outfname={outfname} starting with {line!r}...")
  outlines = [ ] # lines to be written
  
  # READ infile up to \begin{document}
  usedcols = set() # list of used colors
  while line:
    if cmd_dict is not None: # for \newcommand macro in preamble
      match = rexp_newcmd.match(line) # check for macro definition
      if match and (match.group(4).strip()[0]!='}'): # check for macro definition
        cmdname = match.group(3) # macro name
        line    = match.group(4) # rest of the line
        isvalid, line, lines = readscope(infile,line,skipempty=False,inclend=True)
        if isvalid:
          lines[0]  = match.group(1)+lines[0]
          if lines[-1][-1]!='\n':
            lines[-1] = lines[-1]+'\n'
          cmd_dict[cmdname] = lines
        continue # do not include in preamble
    if mac_dict is not None: # for \def macro in preamble
      match = rexp_macro.match(line) # check for macro definition
      if match and (match.group(3).strip()[0]!='}'): # check for macro definition
        macname = match.group(2) # macro name
        line    = match.group(3) # rest of the line
        isvalid, line, lines = readscope(line,skipempty=True)
        if isvalid:
          mac_dict[macname] = lines
        continue # do not include in preamble
    if col_dict is not None: 
      match = rexp_defcol.match(line) # check for color definition
      if match:
        colname = match.group(1) # color name/key
        col_dict[colname] = Color(match) # save color definition
    if for_dict is not None:
      match = rexp_deffor.search(line)
      if match:
        #print(line,match.groups())
        fcmd  = match.group(1)
        vname = re.escape(match.group(2))
        vargs = match.group(3).split(',')
        for_dict[fcmd] = (vname,vargs)
    if rexp_end.search(line): # reached \begin{document}
      if rexp_end==rexp_docbeg:
        break # do not include last line in preamble
      line = line.strip('\n')
      outlines.append(line)
      break # include last line in preamble
    outlines.append(line)
    line = infile.readline() # read next line
  
  # GET PRESETS: \fmfset & \fmfcmd
  if presets is not None:
    i = 0
    presets['all'] = [ ]
    while i<len(outlines):
      line = outlines[i]
      if rexp_fmfset.match(line): # check for color definition
        presets['all'].append(line)
      if rexp_fmfcmd.match(line): # check for style definition
        style = None
        line = ''
        while i<len(outlines): # continue
          line += outlines[i]
          match = rexp_style.search(outlines[i])
          if match:
            assert not style, f"Style was already set! style={style!r}, line={line!r}"
            style = match.group(1)
          if '}' in outlines[i]: # closes \fmfcmd{
            break
          i += 1 # add next line as well
        assert style, f"Did not find style! style={style!r}, line={line!r}"
        style = '{'+style+'}'
        presets[style] = [line]
      i += 1
  
  # WRITE
  with open(outfname,'w') as outfile:
    for outline in outlines:
      if verb>=2:
        print(outline.strip('\n'))
      outfile.write(outline)
  
  return line
  

def subcols(line,col_dict,verb=0):
  """Substitute color commands."""
  rexp_fcol   = re.compile(r"(?<!\.)(f(?:ore|oreground)?\s*=\s*)(\w+)")
  rexp_colcmd = re.compile(r"\\("+'|'.join(col_dict)+")(?!\w)")
  fcolmatch = rexp_fcol.search(line)
  #colcmdmatch = rexp_colcmd.search(line)
  if fcolmatch:
    colname = fcolmatch.group(2)
    if colname not in ['black','white']:
      assert colname in col_dict, f"Did not find colname={colname!r} from line={line!r}"
      rgbval = r"\1"+col_dict[colname].rgb
      line = rexp_fcol.sub(rgbval,line)
  #if '\col' in line:
  #  print(repr(line),repr(rexp_colcmd.sub(r"\\color{\1}",line)))
  line = rexp_colcmd.sub(r"\\color{\1}",line)
  return line
  

def write_fmf(outfname,nfmf,infile,line,prevline="",rexp_end=rexp_fmfend,presets=None,
              preamble=None,col_dict=None,for_dict=None,cmd_dict=None,mac_dict=None,verb=0):
  """Read fmffile."""
  print(f">>> write_fmf: Writing outfname={outfname}...")
  #print(f">>> write_fmf: Writing outfname={outfname} starting with {line!r}...")
  outlines = [ ] # lines to be written
  
  # SPECIAL CASE
  picmatch = rexp_fmfpic.search(line) if rexp_end==rexp_fmfend else None
  if picmatch:
    line = rexp_fmfpic.sub(r"\\begin{fmffile}{feyngraph}\n",line)
    LT = picmatch.group(1)
    RB = picmatch.group(2)
    outlines += [
       "% !TEX program = pdflatexmk\n",
       "% !TEX parameter = -shell-escape\n",
      f"% Author: Izaak Neutelings ({datetime.now().strftime('%B %y')})\n",
       #"% Description: Basic LO QED processes\n",
       "% Instructions: To compile via command line, run the following twice\n",
      f"%   pdflatex -shell-escape {outfname}\n",
    ] + preamble
    line = line
    line += f"  \\fmfframe({LT})({RB}){{ % padding (L,T)(R,B)\n" # prepend
  
  ## INSERT COMMENT
  #if rexp_end==rexp_fmfend and prevline and '%' in prevline[:2]:
  #  outlines.append(prevline) # write comment
  
  # FIND FOREACH
  rexp_var = None # replace these variables/macros
  var_list = [ ]
  match = rexp_foreach.match(prevline)
  if match:
    varname  = re.escape(match.group(1))
    vargs    = match.group(2).split(',')
    rexp_var = re.compile(varname+r"(?!\w)")
    #rexp_var = re.compile(f"({{{varname}}}|{varname})"+r"(?!\w)")
    var_list = [re.escape(v).replace('\{','{').replace('\}','}')
                for v in vargs]
  elif for_dict:
    for forcmd in for_dict:
      if prevline.startswith(forcmd):
        varname, vargs = for_dict[forcmd]
        rexp_var = re.compile(varname+r"(?!\w)")
        var_list = [re.escape(v).replace('\{','{').replace('\}','}')
                    for v in vargs]
  
  # READ infile
  usedcmds = set() # list of used commands
  usedcols = set() # list of used colors
  usedstyles = set() # list of used line styles
  if len(presets['all'])>=1:
    usedstyles.add('all')
  while line:
    if col_dict is not None: # look if line contains use of colname
      line = subcols(line,col_dict,verb=verb) # replace color commands
      for colname, color in col_dict.items():
        if color.longname in line:
          usedcols.add(colname)
    if cmd_dict is not None: # look if line contains use of command
      for cmd in cmd_dict:
        if any(cmd in l for l in cmd_dict[cmd]): # TODO: ensure command matches entire word
          usedcmds.add(cmd)
    if presets is not None:
      for style in presets:
        if style!='all' and style in line:
          usedstyles.add(style)
    if rexp_end.search(line):
      if rexp_end==rexp_docbeg:
        break # don't print or write last line
      if picmatch:
        assert 'fmfpicture' in line
        line = rexp_fmfend.sub(r"  } % close \\fmfframe\n\\end{fmffile}",line)
      line = line.strip('\n')
      outlines.append(line)
      break
    outlines.append(line)
    line = infile.readline() # read next line
  
  # INSERT LINES INTO PREAMBLE
  if preamble and (usedcols or usedcmds):
    i_begdoc = -1
    for i, outline in enumerate(outlines):
      if rexp_docbeg.search(outline):
        i_begdoc = i #+1
        break
    if i_begdoc>0 and usedcols: # colors
      outlines.insert(i_begdoc,"\\usepackage{xcolor}\n")
      for colname in col_dict:
        if colname in usedcols:
          i_begdoc += 1
          outlines.insert(i_begdoc,col_dict[colname].definition)
    if i_begdoc>0 and usedcmds: # newcommands
      if any('brace' in c for c in usedcmds):
        outlines.insert(i_begdoc,"\\usepackage{scalerel}\n")
      for cmd in cmd_dict:
        if cmd in usedcmds:
          i_begdoc += 1
          outlines = outlines[:i_begdoc]+cmd_dict[cmd]+outlines[i_begdoc:]
  if preamble:
    outlines.append("\n\\end{document}")
  
  # INSERT PRESETS
  if picmatch and presets:
    i_graph = -1
    for i, outline in enumerate(outlines):
      if rexp_fmfgrp.search(outline):
        i_graph = i+1
        break
    if i_graph>0 and len(usedstyles)>=1:
      outlines.insert(i_graph,"    % line style\n")
      for style in presets:
        if style in usedstyles:
          for preline in presets[style]:
            i_graph += 1
            outlines.insert(i_graph,'    '+preline.lstrip())
  
  # SUBSTITUTE MACROS
  if mac_dict: # replace macro names
    for outline in outlines[:]:
      for macname in mac_dict:
        if macname in outline:
          npad = len(outline)-len(outline.lstrip())
          i    = outlines.index(outline)
          outlines = outlines[:i] + [' '*npad+l for l in mac_dict[macname]] + outlines[i+1:]
  
  # SUBSTITUTE VARIABLES from foreach
  # Create multiple files if there is multiple variables
  if rexp_var:
    outlinesets = [outlines[:] for v in var_list] # copy list
    for i, outline in enumerate(outlines):
      if rexp_var.search(outline):
        for j, var in enumerate(var_list):
          newline = rexp_var.sub(var,outline)
          matches = rexp_mathrm.search(newline)
          if matches:
            #print(matches.groups())
            substr  = r"\1 \2" if matches.group(1) else r"\2"
            newline = rexp_mathrm.sub(substr,newline)
          outlinesets[j][i] = newline
  else:
    outlinesets = [outlines]
  
  # WRITE
  for outlineset in outlinesets:
    nfmf += 1
    tag = f"-{nfmf:03}"
    outfname_ = outfname.replace('$TAG',tag)
    print(f">>> write_fmf: Writing outfname={green(outfname_)}...")
    with open(outfname_,'w') as outfile:
      for outline in outlineset:
        if verb>=2:
          print(outline.replace('$TAG',tag).strip('\n'))
        outfile.write(outline)
  
  return nfmf
  

def extract(infname,outdir='extract',verb=0):
  """Read."""
  print(f">>> extract: Reading {infname}...")
  
  # FILENAMES
  basename = os.path.basename(infname)
  outfname = os.path.join(outdir,rreplace(basename,'.tex','$TAG.tex'))
  #shutil.copyfile(infname,os.path.join(outdir,basename))
  inbody   = False
  
  # READ INPUT FILE
  nfmf = 0
  prevline = None
  preamble = [ #None
    "\\documentclass[11pt,border=4pt]{standalone}\n",
    "\\usepackage{feynmp-auto}\n",
    "\\begin{document}\n",
  ]
  cmd_dict = { } # macros from \newcommand (to be added to the preamble)
  mac_dict = { } # macros from \def (to be replaced inline)
  col_dict = { } # color definitions (to be replaced inline)
  for_dict = { } # for-loops
  presets  = { } # \fmfset & \fmfcmd presets
  with open(infname,'r') as infile:
    line = infile.readline() # read first line
    while line:
      
      # PREAMBLE (before \begin{document})
      if not inbody:
        tag = f"_preamble"
        outfname_ = outfname.replace('$TAG',tag)
        write_preamble(outfname_,infile,line,rexp_end=rexp_docbeg,presets=presets,
                       col_dict=col_dict,for_dict=for_dict,cmd_dict=cmd_dict,mac_dict=mac_dict,verb=verb)
        inbody = True # past \begin{document}
        #with open(outfname_,'w') as prefile:
        #  preamble = prefile.readlines()
      
      # MAIN BODY (after \begin{document})
      elif rexp_fmfbeg.search(line):
        #print(repr(prevline)+'-'*10,rexp_foreach.search(prevline))
        nfmf = write_fmf(outfname,nfmf,infile,line,rexp_end=rexp_fmfend,preamble=preamble,
                         col_dict=col_dict,for_dict=for_dict,cmd_dict=cmd_dict,mac_dict=mac_dict,presets=presets,
                         prevline=prevline,verb=verb)
      
      prevline = line
      line = infile.readline() # read next line
  
  print(f">>> extract: nfmf={nfmf}")
  

def main(args):
  infnames  = args.infnames
  outdir    = ensuredir(args.outdir)
  dopdf     = args.dopdf or args.doall
  convert   = args.convert or args.doall
  verbosity = args.verbosity+2
  
  for infname in infnames:
    
    # EXTRACT FMFFILES
    extract(infname,outdir=outdir,verb=verbosity)
    
    # COMPILE PDF
    if dopdf:
      tex2pdf(infname,verb=verbosity)
    
    # CONVERT PDF -> PNGs, animated GIF
    if convert:
      pdffname = getpdfname(infname,outdir=outdir)
      pdfnames = splitpdf(pdffname,verb=verbosity)
      pngnames = pdf2png(pdffname,verb=verbosity)
      gifname  = png2gif(pdffname,pngnames,verb=verbosity)
      getfilesize(pdffname,verb=verbosity)
  

if __name__ == '__main__':
  from argparse import ArgumentParser
  description = '''This script extracts fmffile/fmfpicture snippets from LaTeX files into standalone files.'''
  parser = ArgumentParser(description=description,epilog="Good luck!")
  parser.add_argument('infnames',        nargs='+',
                                         help="input TEX files")
  parser.add_argument('-o', '--outdir',  default='extract',
                                         help="output directory, default=%(default)r")
  parser.add_argument('-p', '--pdf',     dest='dopdf', action='store_true',
                                         help="compile input LaTeX file")
  parser.add_argument('-c', '--convert', action='store_true',
                                         help="convert PDF file to PNG & GIF")
  parser.add_argument('-a', '--all',     dest='doall',action='store_true',
                                         help="compile PDF & convert to PNG & GIF")
  parser.add_argument('-v', '--verbose', dest='verbosity', type=int, nargs='?', const=1, default=0,
                                         help="set verbosity level" )
  args = parser.parse_args()
  main(args)
  
